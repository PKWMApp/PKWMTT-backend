package org.pkwmtt.calendar.events.services;

import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.pkwmtt.calendar.events.dto.EventDTO;
import org.pkwmtt.calendar.events.mappers.EventsMapper;
import org.pkwmtt.calendar.events.repositories.EventTypeRepository;
import org.pkwmtt.calendar.events.repositories.EventsRepository;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Service layer for managing events.
 *
 * <p>Provides methods to retrieve events, filter events by superior group,
 * add new events and obtain available event types. This service delegates
 * persistence operations to the {@code EventsRepository} and uses
 * {@code EventsMapper} to convert between entity and DTO representations.
 *
 * <p>Constructor is generated by Lombok's {@code @RequiredArgsConstructor}.
 */
@Service
@RequiredArgsConstructor
public class EventsService {
    
    private final EventsRepository eventsRepository;
    
    private final EventTypeRepository eventTypeRepository;
    
    /**
     * Retrieve all events as DTOs.
     *
     * @return list of all events converted to {@link EventDTO}
     */
    public List<EventDTO> getAllEvents () {
        return eventsRepository.findAll()
          .stream()
          .map(EventsMapper::mapEventToEventDTO)
          .toList();
    }
    
    /**
     * Retrieve events that belong to a superior group with the provided name.
     *
     * <p>The match is case-insensitive.
     *
     * @param superiorGroupName name of the superior group to filter by
     * @return list of events matching the superior group converted to {@link EventDTO}
     */
    public List<EventDTO> getEventsForSuperiorGroup (String superiorGroupName) {
        return eventsRepository.findAll()
          .stream()
          .filter(item -> item.getSuperiorGroups()
            .stream()
            .anyMatch(group -> group.getName().equalsIgnoreCase(superiorGroupName)))
          .map(EventsMapper::mapEventToEventDTO)
          .toList();
    }
    
    /**
     * Persist a new event based on the provided DTO.
     *
     * <p>The DTO is mapped to the entity type, saved and the generated id is returned.
     *
     * @param eventDTO DTO containing event data to persist
     * @return generated id of the saved event
     */
    public int addEvent (EventDTO eventDTO) {
        var eventType = eventTypeRepository.findByName(eventDTO.getType());
        
        if (eventType.isEmpty()) {
            throw new IllegalArgumentException("Invalid event type: " + eventDTO.getType());
        }
        
        var event = EventsMapper.mapEventDTOToEvent(eventDTO, eventType.get());
        eventsRepository.save(event);
        return event.getId();
    }
    
    /**
     * Retrieve all available event types as strings.
     *
     * @return list of event type names
     */
    public List<String> getAllEventTypes () {
        return EventsMapper.mapEventTypeListToListOfString(eventTypeRepository.findAll());
    }
    
    /**
     * Update an existing event using the provided DTO.
     *
     * <p>Validates the DTO's event type exists, maps the DTO to an entity and
     * persists the entity. This method is executed within a transaction so the
     * update will be committed or rolled back atomically.
     *
     * @param eventDTO DTO containing the updated event data
     * @throws IllegalArgumentException if the provided event type does not exist
     */
    @Transactional
    public void updateEvent (EventDTO eventDTO) {
        var eventType = eventTypeRepository
          .findByName(eventDTO.getType()).orElseThrow(() ->
            new IllegalArgumentException(
              "Invalid event type: " + eventDTO.getType())
          );
        
        var eventEntity = EventsMapper.mapEventDTOToEvent(eventDTO, eventType);
        eventsRepository.save(eventEntity);
    }
}